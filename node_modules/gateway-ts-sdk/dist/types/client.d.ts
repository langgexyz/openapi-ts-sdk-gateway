/**
 * Stream Gateway TypeScript SDK - 主客户端
 *
 * 提供基于 WebSocket 的实时通信能力，支持：
 * - 频道订阅/取消订阅
 * - 消息发布
 * - 连接状态监控
 * - 自动重连和重订阅
 * - HTTP 代理转发
 */
import { Client } from 'ts-streamclient';
import type { OnPushMessageCallback } from './types';
import { SubscribeResponse, UnsubscribeResponse, PublishResponse, PingResponse } from './types';
/**
 * Stream Gateway 主客户端类
 *
 * 提供完整的实时通信功能，包括：
 * - 多观察者订阅模式：同一频道可被多个组件订阅
 * - 自动重连和重订阅：网络断开后自动恢复订阅状态
 * - 请求追踪：每个请求都有唯一ID用于日志关联
 */
export declare class StreamGatewayClient {
    private client;
    private callbacks;
    private logger;
    private clientId;
    private rootUri;
    private reconnecter;
    private static globalSeqId;
    /**
     * 设置 API 根路径
     *
     * @param rootUri - 新的根路径 (默认: "API")
     *
     * @example
     * ```typescript
     * // 设置自定义根路径
     * client.setRootUri("CustomAPI");
     *
     * // 恢复默认根路径
     * client.setRootUri("API");
     * ```
     */
    setRootUri(rootUri: string): void;
    /**
     * 获取当前 API 根路径
     *
     * @returns 当前根路径
     */
    getRootUri(): string;
    /**
     * 获取当前已订阅的频道列表 (供 Reconnecter 使用)
     *
     * @returns 频道名称数组
     */
    getSubscribedCommands(): string[];
    /**
     * 停止客户端和清理资源
     *
     * @example
     * ```typescript
     * client.destroy();
     * ```
     */
    destroy(): void;
    /**
     * 生成唯一请求 ID
     *
     * @returns 格式: {random}-{clientId}-{sequence}-{timestamp}
     *
     * @example
     * ```typescript
     * const reqId = client.getNextReqId();
     * const headers = new Map([['X-Req-Id', reqId]]);
     * await client.publish('channel', 'data', headers);
     * ```
     */
    getNextReqId(): string;
    /**
     * 构造函数
     *
     * @param client - 底层 WebSocket 客户端
     * @param clientId - 客户端ID，必须为4位字符，用于请求追踪和日志关联
     *
     * @throws Error 当 clientId 长度不为4时抛出错误
     */
    constructor(client: Client, clientId?: string);
    /**
     * 订阅频道
     *
     * @param cmd - 频道名称
     * @param observer - 观察者标识符 (Symbol)
     * @param callback - 消息回调函数
     * @param headers - 可选请求头部
     *
     * @example
     * ```typescript
     * // 多个组件监听同一频道
     * const NAVBAR = Symbol('navbar');
     * const SIDEBAR = Symbol('sidebar');
     *
     * await client.subscribe('notifications', NAVBAR, handleNavbar);
     * await client.subscribe('notifications', SIDEBAR, handleSidebar);
     *
     * // 精确取消订阅
     * await client.unsubscribe('notifications', NAVBAR);
     * ```
     */
    subscribe(cmd: string, observer: symbol, callback: OnPushMessageCallback, headers?: Map<string, string>): Promise<SubscribeResponse>;
    /**
     * 内部订阅逻辑实现
     *
     * 实现细节：
     * 1. 检查重复订阅，避免同一观察者多次订阅同一频道
     * 2. 先添加本地订阅，再向服务器发送请求
     * 3. 如果服务器订阅失败，回滚本地订阅状态
     * 4. 使用请求ID进行日志追踪
     */
    private subscribeInternal;
    /**
     * 取消订阅
     *
     * @param cmd - 频道名称
     * @param observer - 观察者标识符 (Symbol)
     * @param headers - 可选请求头部
     *
     * @example
     * ```typescript
     * const NAVBAR = Symbol('navbar');
     * await client.unsubscribe('notifications', NAVBAR);
     * ```
     */
    unsubscribe(cmd: string, observer: symbol, headers?: Map<string, string>): Promise<UnsubscribeResponse>;
    /**
     * 内部取消订阅逻辑实现
     *
     * 实现细节：
     * 1. 检查订阅状态，确保观察者已订阅该频道
     * 2. 先移除本地订阅，再决定是否向服务器发送取消订阅请求
     * 3. 只有当频道没有其他订阅者时，才向服务器发送取消订阅请求
     * 4. 优化网络请求：避免不必要的服务器调用
     */
    private unsubscribeInternal;
    /**
     * 发布消息到频道
     *
     * @param cmd - 频道名称
     * @param data - 消息内容 (字符串)
     * @param headers - 可选请求头部
     *
     * @example
     * ```typescript
     * // 发布文本消息
     * await client.publish('notifications', 'Hello World');
     *
     * // 发布 JSON 数据
     * await client.publish('events', JSON.stringify({ type: 'update', data: 'value' }));
     * ```
     */
    publish(cmd: string, data: string, headers?: Map<string, string>): Promise<PublishResponse>;
    /**
     * 测试连接状态
     *
     * @param headers - 可选请求头部
     * @returns 连接正常时返回成功响应
     *
     * @example
     * ```typescript
     * await client.ping();
     * console.log('连接正常');
     * ```
     */
    ping(headers?: Map<string, string>): Promise<PingResponse>;
    /**
     * 通用 API 调用方法
     *
     * 基于 sendRaw 实现，提供类型安全的 JSON 序列化/反序列化
     *
     * @param api - API 端点 (如 'API/Proxy' 或自定义如 'CustomAPI/Proxy')
     * @param data - 请求数据对象，将被序列化为 JSON
     * @param responseType - 响应类型类，用于反序列化响应
     * @param headers - 可选请求头部
     *
     * @example
     * ```typescript
     * // HTTP 代理请求
     * const headers = new Map([
     *   ['x-proxy-url', 'https://api.example.com/data'],
     *   ['x-proxy-method', 'GET']
     * ]);
     *
     * class ApiResponse {
     *   constructor() {
     *     this.code = 0;
     *     this.data = '';
     *   }
     * }
     *
     * const result = await client.send('API/Proxy', {}, ApiResponse, headers);
     * ```
     */
    send<T>(api: string, data: object, responseType: new () => T, headers?: Map<string, string>): Promise<T>;
    /**
     * 发送原始数据请求（用于代理转发）
     *
     * 直接发送字符串数据，返回原始字符串响应，不进行 JSON 编解码
     * 主要用于 HTTP 代理转发，避免不必要的序列化开销
     *
     * @param api - API 路径
     * @param data - 原始数据字符串
     * @param headers - 请求头
     * @returns 原始响应字符串
     *
     * @example
     * ```typescript
     * // 代理转发原始数据
     * const result = await client.sendRaw('API/Proxy', 'raw data', headers);
     * ```
     */
    sendRaw(api: string, data: string, headers?: Map<string, string>): Promise<string>;
}
//# sourceMappingURL=client.d.ts.map