// node_modules/ts-json/src/class.ts
var ClassArray = class _ClassArray extends Array {
  constructor(prototype) {
    super();
    Object.setPrototypeOf(this, _ClassArray.prototype);
    if (typeof prototype === "function") {
      this.itemPrototype = new prototype();
    } else {
      this.itemPrototype = prototype;
    }
    Object.defineProperty(this, "itemPrototype", { enumerable: false });
  }
  newItem() {
    return this.itemPrototype;
  }
  itemPrototype;
};
function getArrayItemPrototype(arr) {
  if (arr instanceof ClassArray) {
    return arr.newItem();
  }
  return arr[0];
}
function isClassArray(arg) {
  return arg !== null && typeof arg === "object" && (arg instanceof ClassArray || arg instanceof Array && arg.length !== 0 && isClass(arg[0]));
}
function isClass(arg) {
  return arg !== null && typeof arg === "object" && !(arg instanceof Array);
}
function isPrimitive(arg) {
  return typeof arg === "number" || typeof arg === "string" || typeof arg === "boolean";
}
function canRecEmptyArray(arg) {
  return typeof arg === "object" && arg instanceof Array;
}
function isPrimitiveArray(arg) {
  return typeof arg === "object" && arg instanceof Array && !(arg instanceof ClassArray) && (arg.length === 0 || isPrimitive(arg[0]));
}

// node_modules/ts-json/src/coder.ts
function hasConstructorDecoder(constructor) {
  let con = constructor;
  return con.decodeJson !== void 0 && typeof con.decodeJson === "function" && con.decodeJson.length === 1;
}
function hasConstructorEncoder(constructor) {
  let con = constructor;
  return con.encodeJson !== void 0 && typeof con.encodeJson === "function" && con.encodeJson.length === 1;
}
function hasDecoder(self) {
  let sf = self;
  return sf.decodeJson !== void 0 && typeof sf.decodeJson === "function" && sf.decodeJson.length === 1;
}
function hasEncoder(self) {
  let sf = self;
  return sf.encodeJson !== void 0 && typeof sf.encodeJson === "function" && sf.encodeJson.length === 0;
}

// node_modules/ts-json/src/type.ts
function isJsonArray(arg) {
  return arg !== null && typeof arg === "object" && arg instanceof Array;
}
function isJsonObject(arg) {
  return arg !== null && typeof arg === "object" && !(arg instanceof Array);
}
function isJsonObjectArray(arg) {
  return isJsonArray(arg) && arg.length === 1 && isJsonObject(arg[0]);
}
function isJsonPrimitive(arg) {
  return typeof arg === "number" || typeof arg === "string" || typeof arg === "boolean";
}
function isJsonEmptyArray(arg) {
  return isJsonArray(arg) && arg.length == 0;
}
function isJsonPrimitiveArray(arg) {
  return isJsonArray(arg) && arg.length !== 0 && isJsonPrimitive(arg[0]);
}

// node_modules/ts-json/src/json.ts
var jsonToPropertySym = Symbol("from-json");
var propertyToJsonSym = Symbol("to-json");
function getPropertyKeys(instance) {
  let keys = [];
  for (let p in instance) {
    if (instance.hasOwnProperty(p) && instance.propertyIsEnumerable(p)) {
      keys.push(p);
    }
  }
  return keys;
}
function isPropertyKey(instance, key) {
  return instance.hasOwnProperty(key) && instance.propertyIsEnumerable(key);
}
var has = Symbol("has");
var Json = class {
  constructor() {
    this.disallowNull();
  }
  ignoreNull() {
    this.nullToJson = (_, _2) => {
    };
    this.fromNullJson = (_, _2) => {
      return null;
    };
    return this;
  }
  allowNull() {
    this.nullToJson = (p, key) => {
      p[key] = null;
    };
    this.fromNullJson = (p, key) => {
      p[key] = null;
      return null;
    };
    return this;
  }
  disallowNull() {
    this.nullToJson = (_, _2) => {
    };
    this.fromNullJson = (_, _2) => {
      return Error("can not null");
    };
    return this;
  }
  nullToJson = (_, _2) => {
  };
  fromNullJson = (_, _2) => {
    return null;
  };
  toJson(instance) {
    let to = this.class2json(instance);
    return JSON.stringify(to);
  }
  toJsonType(instance) {
    return this.class2json(instance);
  }
  class2json(from) {
    if (hasEncoder(from)) {
      return from.encodeJson();
    }
    if (hasConstructorEncoder(from.constructor)) {
      return from.constructor.encodeJson(from);
    }
    let property2jsonMap = from[propertyToJsonSym] || /* @__PURE__ */ new Map();
    let to = {};
    for (let key of getPropertyKeys(from)) {
      let toKey = property2jsonMap.get(key) || key;
      if (toKey === "-") {
        continue;
      }
      let fromV = from[key];
      if (fromV === void 0) {
        continue;
      }
      if (fromV === null) {
        this.nullToJson(to, toKey);
        continue;
      }
      if (isClass(fromV)) {
        to[toKey] = this.class2json(fromV);
        continue;
      }
      if (isClassArray(fromV)) {
        let arr = [];
        for (let item of fromV) {
          arr.push(this.class2json(item));
        }
        to[toKey] = arr;
        continue;
      }
      to[toKey] = fromV;
    }
    return to;
  }
  fromJson(json, prototype) {
    if (typeof prototype === "function") {
      prototype = new prototype();
    }
    if (hasDecoder(prototype)) {
      let err = prototype.decodeJson(json);
      return [prototype, err];
    }
    if (hasConstructorDecoder(prototype.constructor)) {
      return prototype.constructor.decodeJson(json);
    }
    if (typeof json === "string") {
      json = JSON.parse(json);
    }
    if (!isJsonObject(json)) {
      return [prototype, new Error(`${prototype.constructor.name} has not Decoder or ConstructorDecoderso, json must be an object {...} or an object string '{...}'`)];
    }
    return this.json2class(json, prototype, prototype.constructor.name);
  }
  json2class(from, prototype, className) {
    if (hasDecoder(prototype)) {
      let err = prototype.decodeJson(from);
      return [prototype, err];
    }
    if (hasConstructorDecoder(prototype.constructor)) {
      return prototype.constructor.decodeJson(from);
    }
    let json2PropertyMap = prototype[jsonToPropertySym] || /* @__PURE__ */ new Map();
    let property2jsonMap = prototype[propertyToJsonSym] || /* @__PURE__ */ new Map();
    let hasSetKey = /* @__PURE__ */ new Set();
    let hasValue = {};
    for (let key of getPropertyKeys(from)) {
      if (key === "-") {
        continue;
      }
      let toKey = json2PropertyMap.get(key) || key;
      if (property2jsonMap.get(toKey) === "-") {
        continue;
      }
      if (!isPropertyKey(prototype, toKey)) {
        continue;
      }
      hasSetKey.add(toKey);
      hasValue[toKey] = true;
      let propertyName = className + "." + toKey.toString();
      if (from[key] === null) {
        let err2 = this.fromNullJson(prototype, toKey);
        if (err2) {
          return [prototype, Error(propertyName + "---" + err2.message)];
        }
        continue;
      }
      let fromV = from[key];
      let keyProto = prototype[toKey];
      let err = checkType(fromV, keyProto, propertyName);
      if (err !== null) {
        return [prototype, err];
      }
      if (isJsonObjectArray(fromV) && isClassArray(keyProto)) {
        let item = getArrayItemPrototype(keyProto);
        let retArr = new Array();
        for (let i = 0; i < fromV.length; ++i) {
          let [ret, err2] = this.json2class(fromV[i], item, propertyName + `[${i}]`);
          if (err2 !== null) {
            return [prototype, err2];
          }
          retArr.push(ret);
        }
        prototype[toKey] = retArr;
        continue;
      }
      if (isJsonObject(fromV) && isClass(keyProto)) {
        [prototype[toKey], err] = this.json2class(fromV, keyProto, propertyName);
        if (err !== null) {
          return [prototype, err];
        }
        continue;
      }
      prototype[toKey] = fromV;
    }
    for (let key of getPropertyKeys(prototype)) {
      if (!hasSetKey.has(key)) {
        hasValue[key] = false;
      }
    }
    Object.defineProperty(prototype, has, { enumerable: false, value: hasValue, writable: false });
    return [prototype, null];
  }
};
function checkType(fromV, property, className) {
  if (fromV === null) {
    return null;
  }
  if (isJsonObject(fromV) && !isClass(property)) {
    return TypeError(`the json value is '{}', but the property of ${className} is not. 
        Please init the value with "new XXX(...)"`);
  }
  if (isJsonObjectArray(fromV) && !isClassArray(property)) {
    return TypeError(`the json value is '[{}]', but the property of ${className} is not. 
        Please init the value with "new ClassArray(clazz)"`);
  }
  if (property === null || property === void 0) {
    return null;
  }
  if (isJsonPrimitiveArray(fromV) && !isPrimitiveArray(property)) {
    return TypeError(`the json value is '[number|string|boolean]', but the property of ${className} is not. 
        Please init the value with "null or [xxx]"`);
  }
  if (isJsonEmptyArray(fromV) && !canRecEmptyArray(property)) {
    return TypeError(`the json value is '[]', but the property of ${className} is not array type.`);
  }
  if (typeof fromV !== typeof property) {
    return TypeError(`the json value is "<${typeof fromV}>${fromV}", but the property of ${className} is '<${typeof property}>${property}'.
        Please init the value with "null or <${typeof fromV}>"`);
  }
  return null;
}

// src/logger.ts
var _SDKLogger = class _SDKLogger {
  constructor(reqId) {
    this.reqId = reqId;
  }
  /**
   * Log info message
   */
  info(message) {
    console.log(`${_SDKLogger.PREFIX} reqid:${this.reqId} ${message}`);
  }
  /**
   * Log error message
   */
  error(message) {
    console.error(`${_SDKLogger.PREFIX} reqid:${this.reqId} ${message}`);
  }
  /**
   * Log warning message
   */
  warn(message) {
    console.warn(`${_SDKLogger.PREFIX} reqid:${this.reqId} ${message}`);
  }
  /**
   * Log debug message
   */
  debug(message) {
    console.debug(`${_SDKLogger.PREFIX} reqid:${this.reqId} ${message}`);
  }
};
_SDKLogger.PREFIX = "[Gateway]";
var SDKLogger = _SDKLogger;

// src/types.ts
var SubscribeRequest = class {
  constructor() {
    this.cmd = [];
  }
};
var SubscribeResponse = class {
  constructor() {
    this.errMsg = null;
  }
};
var UnsubscribeRequest = class {
  constructor() {
    this.cmd = [];
  }
};
var UnsubscribeResponse = class {
  constructor() {
    this.errMsg = null;
  }
};
var PublishRequest = class {
  constructor() {
    this.cmd = "";
    this.data = "";
  }
  // JSON string
};
var PublishResponse = class {
  constructor() {
    this.errMsg = null;
  }
};
function getHeaderMap(header) {
  const headerMap = /* @__PURE__ */ new Map();
  for (const [key, value] of Object.entries(header)) {
    headerMap.set(key, String(value));
  }
  return headerMap;
}
var PingRequest = class {
  // Empty request matching Go struct
};
var PingResponse = class {
  // Empty response matching Go struct
};
var X_REQ_ID = "X-Req-Id";
var HttpMethod = /* @__PURE__ */ ((HttpMethod2) => {
  HttpMethod2["GET"] = "GET";
  HttpMethod2["POST"] = "POST";
  HttpMethod2["PUT"] = "PUT";
  HttpMethod2["PATCH"] = "PATCH";
  HttpMethod2["DELETE"] = "DELETE";
  HttpMethod2["HEAD"] = "HEAD";
  return HttpMethod2;
})(HttpMethod || {});
var HeaderBuilder = class _HeaderBuilder {
  constructor() {
    this.headers = /* @__PURE__ */ new Map();
  }
  /**
   * 设置 Hook 回调配置
   * 当设置此配置时，subscribe/unsubscribe 等操作会自动触发 Hook 回调到指定的业务服务器
   * 
   * @param url - Hook 回调的目标 URL
   * @param method - HTTP 方法（默认 POST）
   * @returns HeaderBuilder 实例，支持链式调用
   * 
   * @example
   * ```typescript
   * const headers = new HeaderBuilder()
   *   .setHook('https://api.business.com/subscription-hook', HttpMethod.POST)
   *   .build();
   * 
   * // 订阅时会自动触发 Hook 回调业务服务器
   * await client.subscribe('news-channel', headers);
   * ```
   */
  setHook(url, method = "POST" /* POST */) {
    this.headers.set("x-hook-url", url);
    this.headers.set("x-hook-method", method);
    return this;
  }
  /**
   * 设置 Proxy 转发配置
   * 用于 send('API/Proxy', ...) 调用，直接转发 HTTP 请求到目标服务器
   * 
   * @param url - Proxy 转发的目标 URL
   * @param method - HTTP 方法（默认 GET）
   * @returns HeaderBuilder 实例，支持链式调用
   * 
   * @example
   * ```typescript
   * const headers = new HeaderBuilder()
   *   .setProxy('https://api.example.com/data', HttpMethod.GET)
   *   .setReqId('proxy-req-123')
   *   .build();
   * 
   * // 直接转发请求到目标 API
   * const result = await client.send('API/Proxy', {}, ResponseType, headers);
   * ```
   */
  setProxy(url, method = "GET" /* GET */) {
    this.headers.set("x-proxy-url", url);
    this.headers.set("x-proxy-method", method);
    return this;
  }
  /**
   * 设置自定义请求 ID
   * 如果不设置，SDK 会自动生成
   * 
   * @param reqId - 自定义请求 ID
   * @returns HeaderBuilder 实例，支持链式调用
   */
  setReqId(reqId) {
    this.headers.set(X_REQ_ID, reqId);
    return this;
  }
  /**
   * 设置自定义头部
   * @param key - 头部名称
   * @param value - 头部值
   * @returns HeaderBuilder 实例，支持链式调用
   */
  setHeader(key, value) {
    this.headers.set(key, value);
    return this;
  }
  /**
   * 批量添加头部
   * @param headers - 头部键值对对象或 Map
   * @returns HeaderBuilder 实例，支持链式调用
   */
  merge(headers) {
    if (headers instanceof Map) {
      headers.forEach((value, key) => this.headers.set(key, value));
    } else {
      Object.entries(headers).forEach(([key, value]) => this.headers.set(key, value));
    }
    return this;
  }
  /**
   * 构建最终的 headers Map
   * @returns 包含所有头部信息的 Map
   */
  build() {
    return new Map(this.headers);
  }
  /**
   * 创建新的 HeaderBuilder 实例（静态工厂方法）
   * @returns 新的 HeaderBuilder 实例
   */
  static create() {
    return new _HeaderBuilder();
  }
};

// src/client.ts
var X_REQ_ID2 = "X-Req-Id";
var Reconnecter = class {
  constructor(client, logger) {
    this.retryTimer = null;
    this.isActive = true;
    this.client = client;
    this.logger = logger;
  }
  /**
   * 启动重连过程
   */
  start() {
    if (!this.isActive) {
      return;
    }
    this.do();
  }
  /**
   * 停止重连过程
   */
  stop() {
    this.isActive = false;
    if (this.retryTimer) {
      clearTimeout(this.retryTimer);
      this.retryTimer = null;
    }
  }
  /**
   * 执行重连逻辑
   * 使用5秒固定间隔重试，避免指数退避导致的长时间等待
   */
  async do() {
    if (!this.isActive) {
      return;
    }
    const cmdsToResubscribe = this.client.getSubscribedCommands();
    if (cmdsToResubscribe.length === 0) {
      this.logger.debug("[Gateway] Reconnecter: no subscriptions to restore");
      return;
    }
    try {
      this.logger.info(`[Gateway] Reconnecter: attempting to resubscribe ${cmdsToResubscribe.length} commands`);
      const request = new SubscribeRequest();
      request.cmd = cmdsToResubscribe;
      const headers = /* @__PURE__ */ new Map();
      const reqId = this.client.getNextReqId();
      headers.set(X_REQ_ID2, reqId);
      await this.client.send(`${this.client.getRootUri()}/Subscribe`, request, SubscribeResponse, headers);
      this.logger.info(`[Gateway] Reconnecter: resubscribed successfully`);
      if (this.retryTimer) {
        clearTimeout(this.retryTimer);
        this.retryTimer = null;
      }
    } catch (error) {
      this.logger.error(`[Gateway] Reconnecter: failed - ${error}`);
      if (this.isActive) {
        this.logger.info("[Gateway] Reconnecter: will retry in 5s");
        this.retryTimer = setTimeout(() => {
          this.do();
        }, 5e3);
      }
    }
  }
};
var _StreamGatewayClient = class _StreamGatewayClient {
  /**
   * 构造函数
   * 
   * @param client - 底层 WebSocket 客户端
   * @param clientId - 客户端ID，必须为4位字符，用于请求追踪和日志关联
   * 
   * @throws Error 当 clientId 长度不为4时抛出错误
   */
  constructor(client, clientId = "0000") {
    // 观察者回调映射：频道名 -> (观察者ID -> 回调函数)
    // 支持同一频道被多个组件订阅，每个组件用 Symbol 标识
    this.callbacks = /* @__PURE__ */ new Map();
    // API 根路径，默认为 "API"，可通过 setRootUri 修改
    this.rootUri = "API";
    this.client = client;
    if (clientId.length !== 4) {
      throw new Error(`ClientId must be exactly 4 characters, got: ${clientId} (length: ${clientId.length})`);
    }
    this.clientId = clientId;
    this.logger = new SDKLogger(this.clientId);
    this.reconnecter = new Reconnecter(this, this.logger);
    this.client.onPush = async (res) => {
      const rawData = res.toString();
      this.logger.debug(`[Gateway] Raw push data: ${rawData}`);
      let pushData;
      try {
        pushData = JSON.parse(rawData);
      } catch (err) {
        this.logger.error(`[Gateway] Push message parse failed: ${err}`);
        this.logger.error(`[Gateway] Raw data was: ${rawData}`);
        return;
      }
      if (!pushData.cmd || !pushData.data) {
        this.logger.error(`[Gateway] Push message parse failed: invalid message format`);
        this.logger.error(`[Gateway] Raw data was: ${rawData}`);
        return;
      }
      this.logger.debug(`[Gateway] Parsed push message: cmd=${pushData.cmd}, data=${pushData.data}, header=${JSON.stringify(pushData.header)}`);
      const headerMap = getHeaderMap(pushData.header || {});
      const reqId = headerMap.get("X-Req-Id") || "";
      const logger = reqId ? new SDKLogger(reqId) : this.logger;
      if (!reqId) {
        this.logger.warn(`[Gateway] Received push without X-Req-Id - cmd: ${pushData.cmd}, data: ${pushData.data}`);
      } else {
        logger.debug(`[Gateway] Received push - cmd: ${pushData.cmd}, data: ${pushData.data}`);
      }
      const cmdCallbacks = this.callbacks.get(pushData.cmd);
      if (!cmdCallbacks || cmdCallbacks.size === 0) {
        logger.warn(`[Gateway] No observers found for push command: ${pushData.cmd}`);
        return;
      }
      logger.debug(`[Gateway] Dispatching push message to ${cmdCallbacks.size} observers for cmd: ${pushData.cmd}`);
      const callbackPromises = Array.from(cmdCallbacks.entries()).map(async ([observerId, callback]) => {
        try {
          callback(pushData.cmd, pushData.data, headerMap);
          logger.debug(`[Gateway] Observer '${observerId.description || "anonymous"}' handled push message for cmd: ${pushData.cmd}`);
        } catch (error) {
          logger.error(`[Gateway] Observer '${observerId.description || "anonymous"}' failed to handle push message for cmd: ${pushData.cmd}: ${error}`);
        }
      });
      await Promise.allSettled(callbackPromises);
    };
    this.client.onPeerClosed = async (err) => {
      const timestamp = (/* @__PURE__ */ new Date()).toISOString();
      this.logger.warn(`[Gateway] Connection lost at ${timestamp}: ${err}`);
      if (err.toString().includes("1006")) {
        this.logger.warn("[Gateway] 1006: Abnormal connection closure - possible network/proxy issue");
      } else if (err.toString().includes("1001")) {
        this.logger.warn("[Gateway] 1001: Server endpoint going down");
      } else if (err.toString().includes("timeout")) {
        this.logger.warn("[Gateway] Timeout: Connection timed out");
      }
      await this.client.Recover();
      this.reconnecter.start();
    };
  }
  /**
   * 设置 API 根路径
   * 
   * @param rootUri - 新的根路径 (默认: "API")
   * 
   * @example
   * ```typescript
   * // 设置自定义根路径
   * client.setRootUri("CustomAPI");
   * 
   * // 恢复默认根路径
   * client.setRootUri("API");
   * ```
   */
  setRootUri(rootUri) {
    this.rootUri = rootUri;
  }
  /**
   * 获取当前 API 根路径
   * 
   * @returns 当前根路径
   */
  getRootUri() {
    return this.rootUri;
  }
  /**
   * 获取当前已订阅的频道列表 (供 Reconnecter 使用)
   * 
   * @returns 频道名称数组
   */
  getSubscribedCommands() {
    return Array.from(this.callbacks.keys());
  }
  /**
   * 停止客户端和清理资源
   * 
   * @example
   * ```typescript
   * client.destroy();
   * ```
   */
  destroy() {
    this.logger.info(`[Gateway] Client destroyed`);
    this.reconnecter.stop();
    this.callbacks.clear();
  }
  /**
   * 生成唯一请求 ID
   * 
   * @returns 格式: {random}-{clientId}-{sequence}-{timestamp}
   * 
   * @example
   * ```typescript
   * const reqId = client.getNextReqId();
   * const headers = new Map([['X-Req-Id', reqId]]);
   * await client.publish('channel', 'data', headers);
   * ```
   */
  getNextReqId() {
    _StreamGatewayClient.globalSeqId = (_StreamGatewayClient.globalSeqId + 1) % 1e8;
    const random = Math.random().toString(16).substring(2, 10).padStart(8, "0");
    const clientId = this.clientId;
    const seqDecimal = _StreamGatewayClient.globalSeqId.toString().padStart(8, "0");
    const seqHigh = seqDecimal.substring(0, 4);
    const seqLow = seqDecimal.substring(4, 8);
    const timestamp = Date.now().toString();
    return `${random}-${clientId}-${seqHigh}-${seqLow}-${timestamp}`;
  }
  /**
   * 订阅频道
   * 
   * @param cmd - 频道名称
   * @param observer - 观察者标识符 (Symbol)
   * @param callback - 消息回调函数
   * @param headers - 可选请求头部
   * 
   * @example
   * ```typescript
   * // 多个组件监听同一频道
   * const NAVBAR = Symbol('navbar');
   * const SIDEBAR = Symbol('sidebar');
   * 
   * await client.subscribe('notifications', NAVBAR, handleNavbar);
   * await client.subscribe('notifications', SIDEBAR, handleSidebar);
   * 
   * // 精确取消订阅
   * await client.unsubscribe('notifications', NAVBAR);
   * ```
   */
  async subscribe(cmd, observer, callback, headers = /* @__PURE__ */ new Map()) {
    return this.subscribeInternal(cmd, observer, callback, headers);
  }
  /**
   * 内部订阅逻辑实现
   * 
   * 实现细节：
   * 1. 检查重复订阅，避免同一观察者多次订阅同一频道
   * 2. 先添加本地订阅，再向服务器发送请求
   * 3. 如果服务器订阅失败，回滚本地订阅状态
   * 4. 使用请求ID进行日志追踪
   */
  async subscribeInternal(cmd, observer, callback, headers) {
    const cmdCallbacks = this.callbacks.get(cmd);
    if (cmdCallbacks == null ? void 0 : cmdCallbacks.has(observer)) {
      const observerName = observer.description || "anonymous";
      throw new Error(`Observer '${observerName}' already subscribed to command '${cmd}'. Please unsubscribe first.`);
    }
    if (!this.callbacks.has(cmd)) {
      this.callbacks.set(cmd, /* @__PURE__ */ new Map());
    }
    this.callbacks.get(cmd).set(observer, callback);
    const request = new SubscribeRequest();
    request.cmd = [cmd];
    const reqId = headers.get(X_REQ_ID2) || this.getNextReqId();
    headers.set(X_REQ_ID2, reqId);
    const logger = new SDKLogger(reqId);
    try {
      const response = await this.send(`${this.rootUri}/Subscribe`, request, SubscribeResponse, headers);
      const observerName = observer.description || "anonymous";
      logger.info(`[Gateway] Subscription created for cmd '${cmd}' with observer '${observerName}'`);
      return response;
    } catch (error) {
      this.callbacks.get(cmd).delete(observer);
      if (this.callbacks.get(cmd).size === 0) {
        this.callbacks.delete(cmd);
      }
      throw error;
    }
  }
  /**
   * 取消订阅
   * 
   * @param cmd - 频道名称
   * @param observer - 观察者标识符 (Symbol)
   * @param headers - 可选请求头部
   * 
   * @example
   * ```typescript
   * const NAVBAR = Symbol('navbar');
   * await client.unsubscribe('notifications', NAVBAR);
   * ```
   */
  async unsubscribe(cmd, observer, headers = /* @__PURE__ */ new Map()) {
    return this.unsubscribeInternal(cmd, observer, headers);
  }
  /**
   * 内部取消订阅逻辑实现
   * 
   * 实现细节：
   * 1. 检查订阅状态，确保观察者已订阅该频道
   * 2. 先移除本地订阅，再决定是否向服务器发送取消订阅请求
   * 3. 只有当频道没有其他订阅者时，才向服务器发送取消订阅请求
   * 4. 优化网络请求：避免不必要的服务器调用
   */
  async unsubscribeInternal(cmd, observer, headers) {
    const cmdCallbacks = this.callbacks.get(cmd);
    if (!cmdCallbacks || cmdCallbacks.size === 0) {
      throw new Error(`No subscriptions found for command '${cmd}'`);
    }
    if (!cmdCallbacks.has(observer)) {
      const observerName2 = observer.description || "anonymous";
      throw new Error(`Observer '${observerName2}' not found for command '${cmd}'`);
    }
    cmdCallbacks.delete(observer);
    const observerName = observer.description || "anonymous";
    if (cmdCallbacks.size > 0) {
      this.logger.info(`[Gateway] Removed observer '${observerName}' from cmd '${cmd}' (${cmdCallbacks.size} remaining)`);
      const response = new UnsubscribeResponse();
      response.errMsg = null;
      return response;
    }
    this.callbacks.delete(cmd);
    const reqId = headers.get(X_REQ_ID2) || this.getNextReqId();
    headers.set(X_REQ_ID2, reqId);
    const logger = new SDKLogger(reqId);
    logger.info(`[Gateway] Removed last observer for cmd '${cmd}', unsubscribing from server`);
    const request = new UnsubscribeRequest();
    request.cmd = [cmd];
    return await this.send(`${this.rootUri}/Unsubscribe`, request, UnsubscribeResponse, headers);
  }
  /**
   * 发布消息到频道
   * 
   * @param cmd - 频道名称
   * @param data - 消息内容 (字符串)
   * @param headers - 可选请求头部
   * 
   * @example
   * ```typescript
   * // 发布文本消息
   * await client.publish('notifications', 'Hello World');
   * 
   * // 发布 JSON 数据
   * await client.publish('events', JSON.stringify({ type: 'update', data: 'value' }));
   * ```
   */
  async publish(cmd, data, headers = /* @__PURE__ */ new Map()) {
    const request = new PublishRequest();
    request.cmd = cmd;
    request.data = data;
    return await this.send(`${this.rootUri}/Publish`, request, PublishResponse, headers);
  }
  /**
   * 测试连接状态
   * 
   * @param headers - 可选请求头部
   * @returns 连接正常时返回成功响应
   * 
   * @example
   * ```typescript
   * await client.ping();
   * console.log('连接正常');
   * ```
   */
  async ping(headers = /* @__PURE__ */ new Map()) {
    const request = new PingRequest();
    return await this.send(`${this.rootUri}/Ping`, request, PingResponse, headers);
  }
  /**
   * 通用 API 调用方法
   * 
   * 基于 sendRaw 实现，提供类型安全的 JSON 序列化/反序列化
   * 
   * @param api - API 端点 (如 'API/Proxy' 或自定义如 'CustomAPI/Proxy')
   * @param data - 请求数据对象，将被序列化为 JSON
   * @param responseType - 响应类型类，用于反序列化响应
   * @param headers - 可选请求头部
   * 
   * @example
   * ```typescript
   * // HTTP 代理请求
   * const headers = new Map([
   *   ['x-proxy-url', 'https://api.example.com/data'],
   *   ['x-proxy-method', 'GET']
   * ]);
   * 
   * class ApiResponse {
   *   constructor() {
   *     this.code = 0;
   *     this.data = '';
   *   }
   * }
   * 
   * const result = await client.send('API/Proxy', {}, ApiResponse, headers);
   * ```
   */
  async send(api, data, responseType, headers = /* @__PURE__ */ new Map()) {
    const json = new Json();
    const requestData = json.toJson(data);
    const rawResponse = await this.sendRaw(api, requestData, headers);
    const [response, parseErr] = json.fromJson(rawResponse, responseType);
    if (parseErr) {
      const reqId = headers.get(X_REQ_ID2) || this.getNextReqId();
      const logger = new SDKLogger(reqId);
      logger.error(`[Gateway] ${api} response parse error: ${parseErr}`);
      throw parseErr;
    }
    return response;
  }
  /**
   * 发送原始数据请求（用于代理转发）
   * 
   * 直接发送字符串数据，返回原始字符串响应，不进行 JSON 编解码
   * 主要用于 HTTP 代理转发，避免不必要的序列化开销
   * 
   * @param api - API 路径
   * @param data - 原始数据字符串
   * @param headers - 请求头
   * @returns 原始响应字符串
   * 
   * @example
   * ```typescript
   * // 代理转发原始数据
   * const result = await client.sendRaw('API/Proxy', 'raw data', headers);
   * ```
   */
  async sendRaw(api, data, headers = /* @__PURE__ */ new Map()) {
    if (headers.has("api")) {
      throw new Error("Cannot set 'api' header manually. It is automatically set based on api parameter.");
    }
    const header = new Map(headers);
    let reqId = header.get(X_REQ_ID2) || this.getNextReqId();
    header.set(X_REQ_ID2, reqId);
    header.set("api", api);
    const logger = new SDKLogger(reqId);
    const [res, err] = await this.client.Send(data, header);
    if (err) {
      logger.error(`[Gateway] ${api} failed: ${err}`);
      throw err;
    }
    return res.toString();
  }
};
// 全局请求序列号，用于生成唯一请求ID
_StreamGatewayClient.globalSeqId = 0;
var StreamGatewayClient = _StreamGatewayClient;

// node_modules/ts-streamclient/node_modules/ts-xutils/src/duration.ts
var Microsecond = 1;
var Millisecond = 1e3 * Microsecond;
var Second = 1e3 * Millisecond;
var Minute = 60 * Second;
var Hour = 60 * Minute;
function formatDuration(d) {
  let ret = "";
  let left = d;
  let v = Math.floor(left / Hour);
  if (v != 0) {
    ret += `${v}h`;
    left -= v * Hour;
  }
  v = Math.floor(left / Minute);
  if (v != 0) {
    ret += `${v}min`;
    left -= v * Minute;
  }
  v = Math.floor(left / Second);
  if (v != 0) {
    ret += `${v}s`;
    left -= v * Second;
  }
  v = Math.floor(left / Millisecond);
  if (v != 0) {
    ret += `${v}ms`;
    left -= v * Millisecond;
  }
  v = Math.floor(left / Microsecond);
  if (v != 0) {
    ret += `${v}us`;
  }
  if (ret.length == 0) {
    ret = "0us";
  }
  return ret;
}

// node_modules/ts-streamclient/node_modules/ts-xutils/src/utf8.ts
var Utf8 = class _Utf8 {
  raw;
  indexes;
  str;
  byteLength;
  length;
  constructor(input) {
    this.indexes = new Array();
    if (typeof input !== "string") {
      this.raw = new Uint8Array(input);
      this.str = "";
      let utf8i = 0;
      while (utf8i < this.raw.length) {
        this.indexes.push(utf8i);
        let code = _Utf8.loadUTF8CharCode(this.raw, utf8i);
        this.str += String.fromCodePoint(code);
        utf8i += _Utf8.getUTF8CharLength(code);
      }
      this.indexes.push(utf8i);
    } else {
      this.str = input;
      let length = 0;
      for (let ch of input) {
        length += _Utf8.getUTF8CharLength(ch.codePointAt(0));
      }
      this.raw = new Uint8Array(length);
      let index = 0;
      for (let ch of input) {
        this.indexes.push(index);
        index = _Utf8.putUTF8CharCode(this.raw, ch.codePointAt(0), index);
      }
      this.indexes.push(index);
    }
    this.length = this.indexes.length - 1;
    this.byteLength = this.raw.byteLength;
  }
  static loadUTF8CharCode(aChars, nIdx) {
    let nLen = aChars.length, nPart = aChars[nIdx];
    return nPart > 251 && nPart < 254 && nIdx + 5 < nLen ? (
      /* (nPart - 252 << 30) may be not safe in ECMAScript! So...: */
      /* six bytes */
      (nPart - 252) * 1073741824 + (aChars[nIdx + 1] - 128 << 24) + (aChars[nIdx + 2] - 128 << 18) + (aChars[nIdx + 3] - 128 << 12) + (aChars[nIdx + 4] - 128 << 6) + aChars[nIdx + 5] - 128
    ) : nPart > 247 && nPart < 252 && nIdx + 4 < nLen ? (
      /* five bytes */
      (nPart - 248 << 24) + (aChars[nIdx + 1] - 128 << 18) + (aChars[nIdx + 2] - 128 << 12) + (aChars[nIdx + 3] - 128 << 6) + aChars[nIdx + 4] - 128
    ) : nPart > 239 && nPart < 248 && nIdx + 3 < nLen ? (
      /* four bytes */
      (nPart - 240 << 18) + (aChars[nIdx + 1] - 128 << 12) + (aChars[nIdx + 2] - 128 << 6) + aChars[nIdx + 3] - 128
    ) : nPart > 223 && nPart < 240 && nIdx + 2 < nLen ? (
      /* three bytes */
      (nPart - 224 << 12) + (aChars[nIdx + 1] - 128 << 6) + aChars[nIdx + 2] - 128
    ) : nPart > 191 && nPart < 224 && nIdx + 1 < nLen ? (
      /* two bytes */
      (nPart - 192 << 6) + aChars[nIdx + 1] - 128
    ) : (
      /* one byte */
      nPart
    );
  }
  static putUTF8CharCode(aTarget, nChar, nPutAt) {
    let nIdx = nPutAt;
    if (nChar < 128) {
      aTarget[nIdx++] = nChar;
    } else if (nChar < 2048) {
      aTarget[nIdx++] = 192 + (nChar >>> 6);
      aTarget[nIdx++] = 128 + (nChar & 63);
    } else if (nChar < 65536) {
      aTarget[nIdx++] = 224 + (nChar >>> 12);
      aTarget[nIdx++] = 128 + (nChar >>> 6 & 63);
      aTarget[nIdx++] = 128 + (nChar & 63);
    } else if (nChar < 2097152) {
      aTarget[nIdx++] = 240 + (nChar >>> 18);
      aTarget[nIdx++] = 128 + (nChar >>> 12 & 63);
      aTarget[nIdx++] = 128 + (nChar >>> 6 & 63);
      aTarget[nIdx++] = 128 + (nChar & 63);
    } else if (nChar < 67108864) {
      aTarget[nIdx++] = 248 + (nChar >>> 24);
      aTarget[nIdx++] = 128 + (nChar >>> 18 & 63);
      aTarget[nIdx++] = 128 + (nChar >>> 12 & 63);
      aTarget[nIdx++] = 128 + (nChar >>> 6 & 63);
      aTarget[nIdx++] = 128 + (nChar & 63);
    } else {
      aTarget[nIdx++] = 252 + /* (nChar >>> 30) may be not safe in ECMAScript! So...: */
      nChar / 1073741824;
      aTarget[nIdx++] = 128 + (nChar >>> 24 & 63);
      aTarget[nIdx++] = 128 + (nChar >>> 18 & 63);
      aTarget[nIdx++] = 128 + (nChar >>> 12 & 63);
      aTarget[nIdx++] = 128 + (nChar >>> 6 & 63);
      aTarget[nIdx++] = 128 + (nChar & 63);
    }
    return nIdx;
  }
  static getUTF8CharLength(nChar) {
    return nChar < 128 ? 1 : nChar < 2048 ? 2 : nChar < 65536 ? 3 : nChar < 2097152 ? 4 : nChar < 67108864 ? 5 : 6;
  }
  // private static loadUTF16CharCode(aChars: Uint16Array, nIdx: number): number {
  //
  //   /* UTF-16 to DOMString decoding algorithm */
  //   let nFrstChr = aChars[nIdx];
  //
  //   return nFrstChr > 0xD7BF /* 55231 */ && nIdx + 1 < aChars.length ?
  //     (nFrstChr - 0xD800 /* 55296 */ << 10) + aChars[nIdx + 1] + 0x2400 /* 9216 */
  //     : nFrstChr;
  // }
  //
  // private static putUTF16CharCode(aTarget: Uint16Array, nChar: number, nPutAt: number):number {
  //
  //   let nIdx = nPutAt;
  //
  //   if (nChar < 0x10000 /* 65536 */) {
  //     /* one element */
  //     aTarget[nIdx++] = nChar;
  //   } else {
  //     /* two elements */
  //     aTarget[nIdx++] = 0xD7C0 /* 55232 */ + (nChar >>> 10);
  //     aTarget[nIdx++] = 0xDC00 /* 56320 */ + (nChar & 0x3FF /* 1023 */);
  //   }
  //
  //   return nIdx;
  // }
  //
  // private static getUTF16CharLength(nChar: number): number {
  //   return nChar < 0x10000 ? 1 : 2;
  // }
  toString() {
    return this.str;
  }
  // Deprecated
  codePointAt(index) {
    return this.codeUnitAt(index);
  }
  codeUnitAt(index) {
    return this.raw.slice(this.indexes[index], this.indexes[index + 1]);
  }
};

// node_modules/ts-streamclient/node_modules/ts-xutils/src/logger.ts
var TimeFormatter = class {
  Debug(tag, msg) {
    return `${(/* @__PURE__ */ new Date()).toISOString()} Debug: ${tag}  --->  ${msg}`;
  }
  Error(tag, msg) {
    return `${(/* @__PURE__ */ new Date()).toISOString()} Error: ${tag}  --->  ${msg}`;
  }
  Info(tag, msg) {
    return `${(/* @__PURE__ */ new Date()).toISOString()} Info: ${tag}  --->  ${msg}`;
  }
  Warn(tag, msg) {
    return `${(/* @__PURE__ */ new Date()).toISOString()} Warn: ${tag}  --->  ${msg}`;
  }
};
var ConsoleLogger = {
  w: console,
  f: new TimeFormatter()
};

// node_modules/ts-streamclient/node_modules/ts-xutils/src/assert.ts
var AssertError = class {
  message;
  name = "AssertError";
  constructor(m) {
    this.message = m;
  }
};
function assert(condition, msg = "") {
  if (!condition) {
    console.assert(condition, msg);
    throw new AssertError(msg);
  }
}

// node_modules/ts-streamclient/node_modules/ts-xutils/src/typefunc.ts
function RandomInt(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
function UniqFlag() {
  return RandomInt(268435456, Number.MAX_SAFE_INTEGER).toString(16);
}

// node_modules/ts-concurrency/src/queue.ts
var node = class {
  isValid = true;
  element;
  next = null;
  constructor(e) {
    this.element = e;
  }
  inValid() {
    this.isValid = false;
  }
};
var queue = class {
  first = null;
  last = null;
  count = 0;
  en(e) {
    let newNode = new node(e);
    if (this.last == null) {
      this.last = newNode;
      this.first = this.last;
      this.count += 1;
      return newNode;
    }
    this.last.next = newNode;
    this.last = this.last.next;
    this.count += 1;
    return newNode;
  }
  de() {
    while (this.first != null && !this.first.isValid) {
      this.first = this.first.next;
      this.count -= 1;
    }
    if (this.first == null) {
      return null;
    }
    let ret = this.first.element;
    this.first = this.first.next;
    if (this.first == null) {
      this.last = null;
    }
    this.count -= 1;
    return ret;
  }
};

// node_modules/ts-concurrency/src/channel.ts
var ChannelClosed = class {
  message;
  name = "ChannelClosed";
  constructor(m) {
    this.message = m;
  }
};
var Channel = class {
  data = new queue();
  sendSuspend = new queue();
  receiveSuspend = new queue();
  max;
  closed = null;
  constructor(max = 0) {
    this.max = max;
  }
  Close(reason) {
    this.closed = new ChannelClosed(reason ? reason : "");
    for (let s = this.sendSuspend.de(); s != null; s = this.sendSuspend.de()) {
      s[1](this.closed);
    }
    for (let r = this.receiveSuspend.de(); r != null; r = this.receiveSuspend.de()) {
      r(this.closed);
    }
  }
  async Send(e) {
    if (this.closed != null) {
      return this.closed;
    }
    let rfun = this.receiveSuspend.de();
    if (this.data.count >= this.max && rfun == null) {
      return new Promise((resolve) => {
        this.sendSuspend.en([e, resolve]);
      });
    }
    if (rfun != null) {
      rfun(e);
      return null;
    }
    this.data.en(e);
    return null;
  }
  async ReceiveOrFailed() {
    if (this.closed != null) {
      return this.closed;
    }
    let value = this.data.de();
    let suspend = this.sendSuspend.de();
    if (value == null && suspend == null) {
      return new Promise((resolve) => {
        this.receiveSuspend.en(resolve);
      });
    }
    if (value != null) {
      if (suspend != null) {
        let [v2, sfun2] = suspend;
        this.data.en(v2);
        sfun2(null);
      }
      return value;
    }
    let [v, sfun] = suspend;
    sfun(null);
    return v;
  }
  async Receive() {
    let r = await this.ReceiveOrFailed();
    if (r instanceof ChannelClosed) {
      return null;
    }
    return r;
  }
};

// node_modules/ts-concurrency/node_modules/ts-xutils/src/duration.ts
var Microsecond2 = 1;
var Millisecond2 = 1e3 * Microsecond2;
var Second2 = 1e3 * Millisecond2;
var Minute2 = 60 * Second2;
var Hour2 = 60 * Minute2;

// node_modules/ts-concurrency/node_modules/ts-xutils/src/logger.ts
var TimeFormatter2 = class {
  Debug(tag, msg) {
    return `${(/* @__PURE__ */ new Date()).toISOString()} Debug: ${tag}  --->  ${msg}`;
  }
  Error(tag, msg) {
    return `${(/* @__PURE__ */ new Date()).toISOString()} Error: ${tag}  --->  ${msg}`;
  }
  Info(tag, msg) {
    return `${(/* @__PURE__ */ new Date()).toISOString()} Info: ${tag}  --->  ${msg}`;
  }
  Warn(tag, msg) {
    return `${(/* @__PURE__ */ new Date()).toISOString()} Warn: ${tag}  --->  ${msg}`;
  }
};
var ConsoleLogger2 = {
  w: console,
  f: new TimeFormatter2()
};

// node_modules/ts-concurrency/node_modules/ts-xutils/src/assert.ts
var AssertError2 = class {
  message;
  name = "AssertError";
  constructor(m) {
    this.message = m;
  }
};
function assert2(condition, msg = "") {
  if (!condition) {
    console.assert(condition, msg);
    throw new AssertError2(msg);
  }
}

// node_modules/ts-concurrency/src/semaphore.ts
var Semaphore = class {
  acquiredSuspend = new queue();
  max;
  current = 0;
  constructor(max) {
    this.max = max > 1 ? max : 1;
  }
  async Acquire() {
    if (this.current < this.max) {
      this.current += 1;
      return;
    }
    return new Promise((resolve) => {
      this.acquiredSuspend.en(resolve);
    });
  }
  Release() {
    let d = this.acquiredSuspend.de();
    if (d != null) {
      d();
      return;
    }
    this.current -= 1;
    assert2(this.current >= 0);
  }
  ReleaseAll() {
    for (let d = this.acquiredSuspend.de(); d != null; d = this.acquiredSuspend.de()) {
      d();
    }
    this.current = 0;
  }
};

// node_modules/ts-concurrency/src/mutex.ts
var Mutex = class {
  sem = new Semaphore(1);
  async Lock() {
    await this.sem.Acquire();
  }
  Unlock() {
    this.sem.Release();
  }
  async withLock(exe) {
    await this.Lock();
    try {
      return await exe();
    } finally {
      this.Unlock();
    }
  }
};

// node_modules/ts-concurrency/src/timeout.ts
var Timeout = class {
  message;
  name = "Timeout";
  constructor(d) {
    this.message = `timeout: ${d / Millisecond2}ms`;
  }
};
async function withTimeout(d, exe) {
  let timer;
  let timePro = new Promise((resolve) => {
    timer = setTimeout(() => {
      resolve(new Timeout(d));
    }, d / Millisecond2);
  });
  let ret = await Promise.race([exe(), timePro]);
  clearTimeout(timer);
  return ret;
}

// node_modules/ts-concurrency/src/asyncexe.ts
function asyncExe(exe) {
  new Promise(async (resolve) => {
    await exe();
    resolve();
  });
}

// node_modules/ts-streamclient/src/error.ts
var StmErrorBase = class extends Error {
  toString() {
    return this.message;
  }
};
var ConnTimeoutErr = class extends StmErrorBase {
  message;
  name = "ConnTimeoutErr";
  isConnErr = true;
  isTimeoutErr = true;
  get toConnErr() {
    return this;
  }
  constructor(m) {
    super();
    this.message = m;
  }
};
var ElseConnErr = class extends StmErrorBase {
  message;
  name = "ElseConnErr";
  isConnErr = true;
  isTimeoutErr = false;
  get toConnErr() {
    return this;
  }
  constructor(m) {
    super();
    this.message = m;
  }
};
var ElseErr = class extends StmErrorBase {
  message;
  name = "ElseErr";
  cause;
  isConnErr = false;
  isTimeoutErr = false;
  get toConnErr() {
    return new ElseConnErr(this.message);
  }
  constructor(m, cause = null) {
    super();
    if (cause == null) {
      this.message = m;
    } else {
      this.message = `${m}, caused by ${cause.message}`;
    }
    this.cause = cause;
  }
};
function isStmError(arg) {
  return arg instanceof StmErrorBase;
}

// node_modules/ts-streamclient/src/fakehttp.ts
var Request = class _Request {
  buffer;
  get encodedData() {
    return this.buffer;
  }
  get loadLen() {
    return this.buffer.byteLength - 4;
  }
  SetReqId(id) {
    new DataView(this.buffer).setUint32(0, id);
  }
  constructor(buffer) {
    this.buffer = buffer;
  }
  static New(reqId, data, headers) {
    let len = 4;
    let headerArr = new Array();
    let err = null;
    headers.forEach((value, key, _) => {
      let utf8 = { key: new Utf8(key), value: new Utf8(value) };
      if (utf8.key.byteLength > 255 || utf8.value.byteLength > 255) {
        err = new ElseErr(`key(${key})'s length or value(${value})'s length is more than 255`);
        return;
      }
      headerArr.push(utf8);
      len += 1 + utf8.key.byteLength + 1 + utf8.value.byteLength;
    });
    if (err != null) {
      return [new _Request(new ArrayBuffer(0)), err];
    }
    let body = new Utf8(data);
    len += 1 + body.byteLength;
    let ret = new _Request(new ArrayBuffer(len));
    ret.SetReqId(reqId);
    let pos = 4;
    for (let h of headerArr) {
      new DataView(ret.buffer).setUint8(pos, h.key.byteLength);
      pos++;
      new Uint8Array(ret.buffer).set(h.key.raw, pos);
      pos += h.key.byteLength;
      new DataView(ret.buffer).setUint8(pos, h.value.byteLength);
      pos++;
      new Uint8Array(ret.buffer).set(h.value.raw, pos);
      pos += h.value.byteLength;
    }
    new DataView(ret.buffer).setUint8(pos, 0);
    pos++;
    new Uint8Array(ret.buffer).set(body.raw, pos);
    return [ret, null];
  }
};
var Response = class _Response {
  // reqid + status + pushid
  static MaxNoLoadLen = 4 + 1 + 4;
  status;
  reqId = 0;
  data;
  pushId;
  get isPush() {
    return this.reqId == 1;
  }
  constructor(reqId, st, data, pushId = 0) {
    this.reqId = reqId;
    this.status = st;
    this.data = data;
    this.pushId = pushId;
  }
  newPushAck() {
    if (!this.isPush) {
      return [new ArrayBuffer(0), new ElseErr("invalid push data")];
    }
    let ret = new ArrayBuffer(4 + 1 + 4);
    let view = new DataView(ret);
    view.setUint32(0, 1);
    view.setUint8(4, 0);
    view.setUint32(5, this.pushId);
    return [ret, null];
  }
  static ZeroRes() {
    return new _Response(0, 1 /* Failed */, new ArrayBuffer(0));
  }
  static Parse(buffer) {
    if (buffer.byteLength < 5) {
      return [this.ZeroRes(), new ElseErr("fakehttp protocol err(response.size < 5).")];
    }
    let view = new DataView(buffer);
    let reqId = view.getUint32(0);
    let status = view.getUint8(4) == 0 ? 0 /* OK */ : 1 /* Failed */;
    let pushId = 0;
    let offset = 5;
    if (reqId == 1) {
      if (buffer.byteLength < offset + 4) {
        return [this.ZeroRes(), new ElseErr("fakehttp protocol err(response.size of push < 9).")];
      }
      pushId = view.getUint32(offset);
      offset += 4;
    }
    let data = new ArrayBuffer(0);
    if (buffer.byteLength > offset) {
      data = new Uint8Array(buffer).slice(offset).buffer;
    }
    return [new _Response(reqId, status, data, pushId), null];
  }
};

// node_modules/ts-streamclient/src/protocol.ts
var Handshake = class _Handshake {
  HearBeatTime = Number.MAX_SAFE_INTEGER;
  FrameTimeout = Number.MAX_SAFE_INTEGER;
  // 同一帧里面的数据超时
  MaxConcurrent = Number.MAX_SAFE_INTEGER;
  // 一个连接上的最大并发
  MaxBytes = 10 * 1024 * 1024;
  // 一帧数据的最大字节数
  ConnectId = "---no_connectId---";
  toString() {
    return `handshake info:{ConnectId: ${this.ConnectId}, MaxConcurrent: ${this.MaxConcurrent}, HearBeatTime: ${formatDuration(this.HearBeatTime)}, MaxBytes/frame: ${this.MaxBytes}, FrameTimeout: ${formatDuration(this.FrameTimeout)}}`;
  }
  /**
   * ```
   * HeartBeat_s | FrameTimeout_s | MaxConcurrent | MaxBytes | connect id
   * HeartBeat_s: 2 bytes, net order
   * FrameTimeout_s: 1 byte
   * MaxConcurrent: 1 byte
   * MaxBytes: 4 bytes, net order
   * connect id: 8 bytes, net order
   * ```
   */
  static StreamLen = 2 + 1 + 1 + 4 + 8;
  static Parse(buffer) {
    assert(buffer.byteLength >= _Handshake.StreamLen);
    let ret = new _Handshake();
    let view = new DataView(buffer);
    ret.HearBeatTime = view.getUint16(0) * Second;
    ret.FrameTimeout = view.getUint8(2) * Second;
    ret.MaxConcurrent = view.getUint8(3);
    ret.MaxBytes = view.getUint32(4);
    ret.ConnectId = ("00000000" + view.getUint32(8).toString(16)).slice(-8) + ("00000000" + view.getUint32(12).toString(16)).slice(-8);
    return ret;
  }
};

// node_modules/ts-streamclient/src/net.ts
var SyncAllRequest = class {
  allRequests = /* @__PURE__ */ new Map();
  semaphore = new Semaphore(3);
  get permits() {
    return this.semaphore.max;
  }
  set permits(max) {
    this.semaphore = new Semaphore(max);
  }
  constructor(permits = 3) {
    this.semaphore = new Semaphore(permits);
  }
  // channel 必须在 SyncAllRequest 的控制下，所以 Add 获取的只能 receive
  // 要 send 就必须通过 remove 获取
  async Add(reqId) {
    await this.semaphore.Acquire();
    let ch = new Channel(1);
    this.allRequests.set(reqId, ch);
    return ch;
  }
  // 可以用同一个 reqid 重复调用
  Remove(reqId) {
    let ret = this.allRequests.get(reqId) ?? null;
    if (ret != null && this.semaphore.current != 0) {
      this.semaphore.Release();
    }
    this.allRequests.delete(reqId);
    return ret;
  }
  async ClearAllWith(ret) {
    for (let [_, ch] of this.allRequests) {
      await ch.Send(ret);
      await ch.Close();
    }
    this.allRequests.clear();
    await this.semaphore.ReleaseAll();
  }
};
var NotConnect = class _NotConnect {
  isEqual(other) {
    return other instanceof _NotConnect;
  }
  isInvalidated() {
    return false;
  }
  toString() {
    return "NotConnect";
  }
};
var Connected = class _Connected {
  isEqual(other) {
    return other instanceof _Connected;
  }
  isInvalidated() {
    return false;
  }
  toString() {
    return "Connected";
  }
};
var Invalidated = class _Invalidated {
  err;
  isEqual(other) {
    return other instanceof _Invalidated;
  }
  isInvalidated() {
    return true;
  }
  toString() {
    return "Invalidated";
  }
  constructor(err) {
    this.err = err;
  }
};
var ReqId = class _ReqId {
  static reqIdStart = 10;
  value = _ReqId.reqIdStart;
  get() {
    this.value += 1;
    if (this.value < _ReqId.reqIdStart || this.value > Number.MAX_SAFE_INTEGER) {
      this.value = _ReqId.reqIdStart;
    }
    return this.value;
  }
};
var Net = class {
  constructor(logger, protoCreator, onPeerClosed, onPush) {
    this.logger = logger;
    this.onPeerClosed = onPeerClosed;
    this.onPush = onPush;
    logger.w.debug(logger.f.Debug(`Net[${this.flag}].new`, `flag=${this.flag}`));
    this.proto = protoCreator();
    this.proto.logger = logger;
    this.proto.onError = async (err) => {
      await this.onError(err);
    };
    this.proto.onMessage = async (data) => {
      await this.onMessage(data);
    };
  }
  handshake = new Handshake();
  connLocker = new Mutex();
  state = new NotConnect();
  proto;
  reqId = new ReqId();
  allRequests = new SyncAllRequest();
  flag = UniqFlag();
  get connectID() {
    return this.handshake.ConnectId;
  }
  get isInvalid() {
    return this.state.isInvalidated();
  }
  async closeAndOldState(err) {
    let old = await this.connLocker.withLock(async () => {
      let old2 = this.state;
      if (this.state.isInvalidated()) {
        return old2;
      }
      this.state = new Invalidated(err);
      this.logger.w.debug(this.logger.f.Debug(`Net[${this.flag}]<${this.connectID}>.Invalidated`, `${err}`));
      return old2;
    });
    await this.allRequests.ClearAllWith([Response.ZeroRes(), err.toConnErr]);
    return old;
  }
  async onError(err) {
    let old = await this.closeAndOldState(err);
    if (old instanceof Connected) {
      asyncExe(async () => {
        this.logger.w.debug(this.logger.f.Debug(
          `Net[${this.flag}]<${this.connectID}>.close`,
          "closed, become invalidated"
        ));
        await this.onPeerClosed(err);
        await this.proto.Close();
      });
    }
  }
  async onMessage(msg) {
    let [response, err] = Response.Parse(msg);
    if (err) {
      this.logger.w.debug(this.logger.f.Debug(
        `Net[${this.flag}]<${this.connectID}>.onMessage:parse`,
        `error --- ${err}`
      ));
      await this.onError(err);
      return;
    }
    if (response.isPush) {
      let [pushAck, err2] = response.newPushAck();
      if (err2) {
        this.logger.w.debug(this.logger.f.Debug(
          `Net[${this.flag}]<${this.connectID}>.onMessage:newPushAck`,
          `error --- ${err2}`
        ));
        await this.onError(err2);
        return;
      }
      asyncExe(async () => {
        await this.onPush(response.data);
      });
      asyncExe(async () => {
        let err3 = await this.proto.Send(pushAck);
        if (err3) {
          this.logger.w.debug(this.logger.f.Debug(
            `Net[${this.flag}]<${this.connectID}>.onMessage:pushAck`,
            `error --- ${err3}`
          ));
        }
        this.logger.w.debug(this.logger.f.Debug(
          `Net[${this.flag}]<${this.connectID}>.onMessage:pushAck`,
          `pushID = ${response.pushId}`
        ));
      });
      return;
    }
    let ch = await this.allRequests.Remove(response.reqId);
    if (ch == null) {
      this.logger.w.debug(this.logger.f.Warn(
        `Net[${this.flag}]<${this.connectID}>.onMessage:NotFind`,
        `warning: not find request for reqId(${response.reqId}`
      ));
      return;
    }
    let ch1 = ch;
    this.logger.w.debug(this.logger.f.Debug(
      `Net[${this.flag}]<${this.connectID}>.onMessage:response`,
      `reqId=${response.reqId}`
    ));
    asyncExe(async () => {
      await ch1.Send([response, null]);
    });
  }
  // 可重复调用
  async connect() {
    return await this.connLocker.withLock(async () => {
      if (this.state instanceof Connected) {
        this.logger.w.debug(this.logger.f.Debug(`Net[${this.flag}].connect:Connected`, `connID=${this.connectID}`));
        return null;
      }
      if (this.state.isInvalidated()) {
        this.logger.w.debug(this.logger.f.Debug(
          `Net[${this.flag}].connect<${this.connectID}>:Invalidated`,
          `${this.state.err}`
        ));
        return this.state.err;
      }
      this.logger.w.debug(this.logger.f.Debug(`Net[${this.flag}].connect:NotConnect`, "will connect"));
      let [handshake, err] = await this.proto.Connect();
      if (err != null) {
        this.state = new Invalidated(err);
        this.logger.w.debug(this.logger.f.Debug(`Net[${this.flag}].connect:error`, `${err}`));
        return err;
      }
      this.state = new Connected();
      this.handshake = handshake;
      this.allRequests.permits = this.handshake.MaxConcurrent;
      this.logger.w.debug(this.logger.f.Debug(
        `Net[${this.flag}]<${this.connectID}>.connect:handshake`,
        `${this.handshake}`
      ));
      return null;
    });
  }
  // 如果没有连接成功，直接返回失败
  async send(data, headers, timeout = 30 * Second) {
    let ret = await this.connLocker.withLock(async () => {
      this.logger.w.debug(this.logger.f.Debug(
        `Net[${this.flag}]<${this.connectID}>.send:state`,
        `${this.state} --- headers:${formatMap(headers)}`
      ));
      if (this.state.isInvalidated()) {
        return this.state.err.toConnErr;
      }
      if (!(this.state instanceof Connected)) {
        return new ElseConnErr("not connected");
      }
      return null;
    });
    if (ret) {
      return [new ArrayBuffer(0), ret];
    }
    let reqId = this.reqId.get();
    let [request, err] = Request.New(reqId, data, headers);
    if (err) {
      this.logger.w.debug(this.logger.f.Debug(
        `Net[${this.flag}]<${this.connectID}>.send:FakeHttpRequest`,
        `headers:${formatMap(headers)} (reqId:${reqId}) --- error: ${err}`
      ));
      return [new ArrayBuffer(0), err];
    }
    if (request.loadLen > this.handshake.MaxBytes) {
      this.logger.w.debug(this.logger.f.Debug(
        `Net[${this.flag}]<${this.connectID}>.send:MaxBytes`,
        `headers:${formatMap(headers)} (reqId:${reqId}) --- error: data is Too Large`
      ));
      return [
        new ArrayBuffer(0),
        new ElseErr(`request.size(${request.loadLen}) > MaxBytes(${this.handshake.MaxBytes})`)
      ];
    }
    this.logger.w.debug(this.logger.f.Debug(
      `Net[${this.flag}]<${this.connectID}>.send[${reqId}]:request`,
      `headers:${formatMap(headers)} (reqId:${reqId})`
    ));
    let ch = await this.allRequests.Add(reqId);
    let ret2 = await withTimeout(timeout, async () => {
      asyncExe(async () => {
        var _a;
        let err2 = await this.proto.Send(request.encodedData);
        if (err2) {
          await ((_a = this.allRequests.Remove(reqId)) == null ? void 0 : _a.Send([Response.ZeroRes(), err2]));
        }
      });
      let r = await ch.Receive();
      if (r) {
        return r;
      }
      return [Response.ZeroRes(), new ElseErr("channel is closed, exception!!!")];
    });
    if (ret2 instanceof Timeout) {
      this.logger.w.debug(this.logger.f.Debug(
        `Net[${this.flag}]<${this.connectID}>.send[${reqId}]:Timeout`,
        `headers:${formatMap(headers)} (reqId:${reqId}) --- timeout(>${timeout / Second}s)`
      ));
      return [new ArrayBuffer(0), new ElseErr(`request timeout(${timeout / Second}s)`)];
    }
    if (ret2[1]) {
      return [new ArrayBuffer(0), ret2[1]];
    }
    this.logger.w.debug(this.logger.f.Debug(
      `Net[${this.flag}]<${this.connectID}>.send[${reqId}]:response`,
      `headers:${formatMap(headers)} (reqId:${reqId}) --- ${ret2[0].status}`
    ));
    if (ret2[0].status != 0 /* OK */) {
      return [new ArrayBuffer(0), new ElseErr(new Utf8(ret2[0].data).toString())];
    }
    await this.allRequests.Remove(reqId);
    return [ret2[0].data, null];
  }
  async close() {
    let old = await this.closeAndOldState(new ElseErr("closed by self"));
    if (old instanceof Connected) {
      this.logger.w.debug(this.logger.f.Debug(
        `Net[${this.flag}]<${this.connectID}>.close`,
        "closed, become invalidated"
      ));
      await this.proto.Close();
    }
  }
};
function formatMap(map) {
  let ret = new Array();
  map.forEach((v, k) => {
    ret.push(k + ":" + v);
  });
  return "{" + ret.join(", ") + "}";
}

// node_modules/ts-streamclient/src/client.ts
var Result = class {
  constructor(data = new ArrayBuffer(0)) {
    this.data = data;
  }
  toString() {
    return new Utf8(this.data).toString();
  }
  utf8RawBuffer() {
    return this.data;
  }
};
var Client = class _Client {
  constructor(protocolCreator, logger = ConsoleLogger) {
    this.protocolCreator = protocolCreator;
    this.logger = logger;
    logger.w.info(logger.f.Info(`Client[${this.flag}].new`, `flag=${this.flag}`));
    this.net_ = this.newNet();
  }
  onPush = async () => {
  };
  onPeerClosed = async () => {
  };
  flag = UniqFlag();
  netMutex = new Mutex();
  net_;
  newNet() {
    return new Net(this.logger, this.protocolCreator, async (err) => {
      this.logger.w.warn(this.logger.f.Warn(`Client[${this.flag}].onPeerClosed`, `reason: ${err}`));
      await this.onPeerClosed(err);
    }, async (data) => {
      this.logger.w.info(this.logger.f.Info(`Client[${this.flag}].onPush`, `size: ${data.byteLength}`));
      await this.onPush(new Result(data));
    });
  }
  async net() {
    return await this.netMutex.withLock(async () => {
      if (this.net_.isInvalid) {
        await this.net_.close();
        this.net_ = this.newNet();
      }
      return this.net_;
    });
  }
  async Send(data, headers, timeout = 30 * Second) {
    let sflag = headers.get(_Client.reqidKey) ?? UniqFlag();
    let utf8Data = new Utf8(data);
    this.logger.w.info(this.logger.f.Info(
      `Client[${this.flag}].Send[${sflag}]:start`,
      `headers:${formatMap(headers)}, request utf8 size = ${utf8Data.byteLength}`
    ));
    let net = await this.net();
    let err = await net.connect();
    if (err) {
      this.logger.w.error(this.logger.f.Error(
        `Client[${this.flag}].Send[${sflag}]:error`,
        `connect error: ${err}`
      ));
      return [new Result(), err];
    }
    let [ret, err2] = await net.send(utf8Data.raw.buffer, headers, timeout);
    if (err2 == null) {
      this.logger.w.info(this.logger.f.Info(
        `Client[${this.flag}].Send[${sflag}](connID=${net.connectID}):end`,
        `response size = ${ret.byteLength}`
      ));
      return [new Result(ret), err2];
    }
    if (!err2.isConnErr) {
      this.logger.w.error(this.logger.f.Error(
        `Client[${this.flag}].Send[${sflag}](connID=${net.connectID}):error`,
        `request error = ${err2}`
      ));
      return [new Result(ret), err2];
    }
    this.logger.w.debug(this.logger.f.Debug(`Client[${this.flag}].Send[${sflag}]:retry`, `retry-1`));
    net = await this.net();
    err = await net.connect();
    if (err) {
      this.logger.w.error(this.logger.f.Error(`Client[${this.flag}].Send[${sflag}]:error`, `connect error: ${err}`));
      return [new Result(), err];
    }
    [ret, err2] = await net.send(utf8Data.raw.buffer, headers, timeout);
    if (err2 == null) {
      this.logger.w.info(this.logger.f.Info(
        `Client[${this.flag}].Send[${sflag}](connID=${net.connectID}):end`,
        `response size = ${ret.byteLength}`
      ));
    } else {
      this.logger.w.error(this.logger.f.Error(
        `Client[${this.flag}].Send[${sflag}](connID=${net.connectID}):error`,
        `request error = ${err2}`
      ));
    }
    return [new Result(ret), err2];
  }
  /**
   * Close 后，Client 仍可继续使用，下次发送请求时，会自动重连
   * Close() 调用不会触发 onPeerClosed()
   * Close() 与 其他接口没有明确的时序关系，Close() 调用后，也可能会出现 Send() 的调用返回 或者 onPeerClosed()
   * 		但此时的 onPeerClosed() 并不是因为 Close() 而触发的。
   */
  async Close() {
    await this.netMutex.withLock(async () => {
      this.logger.w.info(this.logger.f.Info(`Client[${this.flag}].close`, "closed by self"));
      await this.net_.close();
    });
  }
  UpdateProtocol(creator) {
    this.protocolCreator = creator;
  }
  async Recover() {
    return await (await this.net()).connect();
  }
  static reqidKey = "X-Req-Id";
  async SendWithReqId(data, headers, timeout = 30 * Second) {
    headers.set(_Client.reqidKey, UniqFlag());
    return await this.Send(data, headers, timeout);
  }
};

// node_modules/ts-streamclient/src/websocket.ts
var AbstractWebSocketDriver = class {
  onclose = () => {
  };
  onerror = () => {
  };
  onmessage = () => {
  };
  onopen = () => {
  };
};
var dummyWs = class extends AbstractWebSocketDriver {
  close() {
  }
  send() {
  }
};
var WebSocketProtocol = class {
  constructor(url, driverCreator, connectTimeout = 30 * Second) {
    this.url = url;
    this.driverCreator = driverCreator;
    this.connectTimeout = connectTimeout;
    if (url.indexOf("s://") === -1) {
      this.url = "ws://" + url;
    }
  }
  logger_ = ConsoleLogger;
  onMessage = async () => {
  };
  onError = async () => {
  };
  closeBySelf = false;
  handshake = new Handshake();
  get connectID() {
    return this.handshake.ConnectId;
  }
  flag = UniqFlag();
  driver = new dummyWs();
  get logger() {
    return this.logger_;
  }
  set logger(l) {
    this.logger_ = l;
    this.logger_.w.debug(this.logger_.f.Debug(`WebSocket[${this.flag}].new`, `flag=${this.flag}`));
  }
  async Close() {
    this.closeBySelf = true;
    this.driver.close();
    this.driver = new dummyWs();
  }
  createDriver(handshakeChannel) {
    let isConnecting = true;
    this.driver = this.driverCreator(this.url);
    this.driver.onclose = (ev) => {
      if (isConnecting) {
        isConnecting = false;
        asyncExe(async () => {
          this.logger.w.debug(this.logger.f.Debug(`WebSocket[${this.flag}].onclose`, `${ev.code} ${ev.reason}`));
          await handshakeChannel.Send(new ElseConnErr(`closed: ${ev.code} ${ev.reason}`));
        });
        return;
      }
      if (!this.closeBySelf) {
        asyncExe(async () => {
          this.logger.w.debug(this.logger.f.Debug(
            `WebSocket[${this.flag}].onclose`,
            `closed by peer: ${ev.code} ${ev.reason}`
          ));
          await this.onError(new ElseConnErr(`closed by peer: ${ev.code} ${ev.reason}`));
        });
      }
    };
    this.driver.onerror = (ev) => {
      if (isConnecting) {
        isConnecting = false;
        asyncExe(async () => {
          this.logger.w.debug(this.logger.f.Debug(`WebSocket[${this.flag}].onerror`, ev.errMsg));
          await handshakeChannel.Send(new ElseConnErr(ev.errMsg));
        });
        return;
      }
      if (!this.closeBySelf) {
        asyncExe(async () => {
          this.logger.w.debug(this.logger.f.Debug(`WebSocket[${this.flag}].onerror`, `${ev.errMsg}`));
          await this.onError(new ElseConnErr(ev.errMsg));
        });
      }
    };
    this.driver.onmessage = (ev) => {
      if (typeof ev.data == "string") {
        this.logger.w.debug(this.logger.f.Debug(`WebSocket[${this.flag}].onmessage:error`, "message type error"));
        asyncExe(async () => {
          await this.onError(new ElseConnErr("message type error"));
        });
        return;
      }
      let data = ev.data;
      if (isConnecting) {
        isConnecting = false;
        asyncExe(async () => {
          await handshakeChannel.Send(data);
        });
        return;
      }
      asyncExe(async () => {
        this.logger.w.debug(this.logger.f.Debug(
          `WebSocket[${this.flag}]<${this.connectID}>.read`,
          `read one message`
        ));
        await this.onMessage(data);
      });
    };
    this.driver.onopen = () => {
      this.logger.w.debug(this.logger.f.Debug(`WebSocket[${this.flag}].onopen`, `waiting for handshake`));
    };
  }
  async Connect() {
    this.logger.w.debug(this.logger.f.Debug(
      `WebSocket[${this.flag}].Connect:start`,
      `${this.url}#connectTimeout=${this.connectTimeout}`
    ));
    let handshakeChannel = new Channel(1);
    this.createDriver(handshakeChannel);
    let handshake = await withTimeout(this.connectTimeout, async () => {
      return await handshakeChannel.Receive();
    });
    if (handshake instanceof Timeout) {
      this.logger.w.debug(this.logger.f.Debug(`WebSocket[${this.flag}].Connect:error`, "timeout"));
      return [new Handshake(), new ConnTimeoutErr("timeout")];
    }
    if (isStmError(handshake)) {
      this.logger.w.debug(this.logger.f.Debug(`WebSocket[${this.flag}].Connect:error`, `${handshake}`));
      return [new Handshake(), handshake];
    }
    if (handshake == null) {
      this.logger.w.debug(this.logger.f.Debug(`WebSocket[${this.flag}].Connect:error`, "channel closed"));
      return [new Handshake(), new ElseConnErr("channel closed")];
    }
    if (handshake.byteLength != Handshake.StreamLen) {
      this.logger.w.debug(this.logger.f.Debug(
        `WebSocket[${this.flag}].Connect:error`,
        `handshake(${handshake.byteLength}) size error`
      ));
      return [new Handshake(), new ElseConnErr(`handshake(${handshake.byteLength}) size error`)];
    }
    this.handshake = Handshake.Parse(handshake);
    this.logger.w.debug(this.logger.f.Debug(
      `WebSocket[${this.flag}]<${this.connectID}>.Connect:end`,
      `connectID = ${this.connectID}`
    ));
    return [this.handshake, null];
  }
  async Send(data) {
    this.driver.send(data);
    this.logger.w.debug(this.logger.f.Debug(
      `WebSocket[${this.flag}]<${this.connectID}>.Send`,
      `frameBytes = ${data.byteLength}`
    ));
    return null;
  }
};

// node_modules/ts-streamclient/src/browserws.ts
var BrowserWs = class extends AbstractWebSocketDriver {
  websocket;
  close(code, reason) {
    this.websocket.close(code, reason);
  }
  send(data) {
    this.websocket.send(data);
  }
  constructor(url) {
    super();
    this.websocket = new WebSocket(url);
    this.websocket.binaryType = "arraybuffer";
    this.websocket.onclose = (ev) => {
      this.onclose(ev);
    };
    this.websocket.onerror = (ev) => {
      this.onerror({ errMsg: "BrowserWebSocket onerror: " + ev.toString() });
    };
    this.websocket.onmessage = (ev) => {
      this.onmessage(ev);
    };
    this.websocket.onopen = (ev) => {
      this.onopen(ev);
    };
  }
};
function withBrowser(url, connectionTimeout = 30 * Second) {
  return () => {
    return new WebSocketProtocol(url, (url2) => {
      return new BrowserWs(url2);
    }, connectionTimeout);
  };
}

// src/index.ts
function createClient(wsUrl, clientId) {
  const client = new Client(withBrowser(wsUrl));
  return new StreamGatewayClient(client, clientId);
}
var index_default = StreamGatewayClient;
export {
  Client,
  HeaderBuilder,
  HttpMethod,
  PingRequest,
  PingResponse,
  PublishRequest,
  PublishResponse,
  SDKLogger,
  StreamGatewayClient,
  SubscribeRequest,
  SubscribeResponse,
  UnsubscribeRequest,
  UnsubscribeResponse,
  X_REQ_ID,
  createClient,
  index_default as default,
  getHeaderMap,
  withBrowser
};
